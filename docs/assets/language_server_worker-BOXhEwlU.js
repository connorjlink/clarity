var J=Object.defineProperty;var B=(T,m,f)=>m in T?J(T,m,{enumerable:!0,configurable:!0,writable:!0,value:f}):T[m]=f;var h=(T,m,f)=>B(T,typeof m!="symbol"?m+"":m,f);(function(){"use strict";function T(i,t,e=null){return{jsonrpc:"2.0",method:i,params:t,id:e}}function m(i,t){return{jsonrpc:"2.0",result:t,id:i}}function f(i,t,e,n){return{jsonrpc:"2.0",error:{code:t,message:e,data:n},id:i}}const x={PARSE_ERROR:{code:-32700,message:"Parse error"},METHOD_NOT_FOUND:{code:-32601,message:"Method not found"},INVALID_PARAMS:{code:-32602,message:"Invalid params"},SERVER_NOT_INITIALIZED:{code:-32002,message:"Server not initialized"}};var p;(i=>{i.Error=1,i.Warning=2,i.Info=3,i.Log=4,i.Debug=5})(p||(p={}));var u;(i=>{i.File=1,i.Module=2,i.Namespace=3,i.Package=4,i.Class=5,i.Method=6,i.Property=7,i.Field=8,i.Constructor=9,i.Enum=10,i.Interface=11,i.Function=12,i.Variable=13,i.Constant=14,i.String=15,i.Number=16,i.Boolean=17,i.Array=18,i.Object=19,i.Key=20,i.Null=21,i.EnumMember=22,i.Struct=23,i.Event=24,i.Operator=25,i.TypeParameter=26})(u||(u={}));var M;(i=>{i.None=0,i.Full=1,i.Incremental=2})(M||(M={}));var N;(i=>{i.Text=1,i.Read=2,i.Write=3})(N||(N={}));var P;(i=>{i.Error=1,i.Warning=2,i.Information=3,i.Hint=4})(P||(P={}));var l;(i=>{i.Text=1,i.Method=2,i.Function=3,i.Constructor=4,i.Field=5,i.Variable=6,i.Class=7,i.Interface=8,i.Module=9,i.Property=10,i.Unit=11,i.Value=12,i.Enum=13,i.Keyword=14,i.Snippet=15,i.Color=16,i.File=17,i.Reference=18,i.Folder=19,i.EnumMember=20,i.Constant=21,i.Struct=22,i.Event=23,i.Operator=24,i.TypeParameter=25})(l||(l={}));function F(i){switch(i){case"file":return u.File;case"module":return u.Module;case"namespace":return u.Namespace;case"package":return u.Package;case"class":return u.Class;case"method":return u.Method;case"property":return u.Property;case"field":return u.Field;case"constructor":return u.Constructor;case"enum":return u.Enum;case"interface":return u.Interface;case"function":return u.Function;case"variable":return u.Variable;case"constant":return u.Constant;case"string":return u.String;case"number":return u.Number;case"boolean":return u.Boolean;case"array":return u.Array;case"object":return u.Object;case"key":return u.Key;case"null":return u.Null;case"enumerator":return u.EnumMember;case"struct":return u.Struct;case"event":return u.Event;case"operator":return u.Operator;case"typeParameter":return u.TypeParameter;default:return u.Object}}class k{constructor(t,e,n=[],s=0){h(this,"symbolsByName",new Map);h(this,"symbolsByLocation",new Map);h(this,"symbolsByComposite",new Map);h(this,"symbols",[]);h(this,"diagnostics",[]);h(this,"editDeltas",[]);h(this,"lastGetTextVersion",-1);h(this,"text","");this.uri=t,this.languageId=e,this.lines=n,this.version=s}addDiagnostic(t){this.diagnostics.push(t)}getDiagnostics(){return this.diagnostics.map(t=>({...t,range:{start:this.applyDeltasToPosition(t.range.start),end:this.applyDeltasToPosition(t.range.end)}}))}getSymbolsByName(t){const e=this.symbolsByName.get(t);return e?e.map(n=>({symbol:{...n.symbol,location:{...n.symbol.location,range:{start:this.applyDeltasToPosition(n.symbol.location.range.start),end:this.applyDeltasToPosition(n.symbol.location.range.end)}}},isDeclaration:n.isDeclaration})):[]}getSymbolsByNamePrefix(t){const e=[];for(const[n,s]of this.symbolsByName.entries())if(n.startsWith(t))for(const o of s)e.push({symbol:{...o.symbol,location:{...o.symbol.location,range:{start:this.applyDeltasToPosition(o.symbol.location.range.start),end:this.applyDeltasToPosition(o.symbol.location.range.end)}}},isDeclaration:o.isDeclaration});return e}getSymbolByPosition(t){const e=this.revertDeltasFromPosition(t),n=this.symbolsByLocation.get(e);return n?{symbol:{...n.symbol,location:{...n.symbol.location,range:{start:this.applyDeltasToPosition(n.symbol.location.range.start),end:this.applyDeltasToPosition(n.symbol.location.range.end)}}},isDeclaration:n.isDeclaration}:null}getTextFragmentBeforePosition(t){const e=this.revertDeltasFromPosition(t),n=this.lines[e.line]||"",s=e.character,r=n.slice(0,s).match(/[a-zA-Z_][a-zA-Z0-9_]*$/);return r?r[0]:null}getSymbolAroundPosition(t){const e=this.revertDeltasFromPosition(t);for(const n of this.symbols){const s=n.symbol.location.range;if((e.line>s.start.line||e.line===s.start.line&&e.character>=s.start.character)&&(e.line<s.end.line||e.line===s.end.line&&e.character<=s.end.character))return{symbol:{...n.symbol,location:{...n.symbol.location,range:{start:this.applyDeltasToPosition(s.start),end:this.applyDeltasToPosition(s.end)}}},isDeclaration:n.isDeclaration}}return null}getAllSymbols(){return this.symbols.map(t=>({...t,location:{...t.symbol.location,range:{start:this.applyDeltasToPosition(t.symbol.location.range.start),end:this.applyDeltasToPosition(t.symbol.location.range.end)}}}))}addOrUpdateSymbol(t,e){const n=t.symbol.location.range.start,s=k.compositeKey(e,n);let o=this.symbolsByComposite.get(s);o?Object.assign(o,t):(this.symbolsByName.has(e)||this.symbolsByName.set(e,[]),this.symbols.push(t),this.symbolsByName.get(e).push(t),this.symbolsByLocation.set(n,t),this.symbolsByComposite.set(s,t))}invalidateSymbols(){this.symbols=[],this.symbolsByName.clear(),this.symbolsByLocation.clear(),this.symbolsByComposite.clear(),this.editDeltas=[]}upsertRawSymbol(t){const e=JSON.parse(t);this.upsertSymbol(e)}upsertSymbol(t){var s;const n={symbol:{name:t.name,kind:F(t.type),location:{uri:this.uri,range:{start:{line:t.location.line,character:t.location.column},end:{line:t.location.line,character:t.location.column+(((s=t.text)==null?void 0:s.length)??1)}}}},isDeclaration:t.isDeclaration};this.addOrUpdateSymbol(n,t.name)}applyDeltasToPosition(t){let e={...t};for(const n of this.editDeltas)(e.line>n.range.end.line||e.line===n.range.end.line&&e.character>=n.range.end.character)&&(e.line+=n.lineDelta,e.line===n.range.end.line&&(e.character+=n.charDelta));return e}revertDeltasFromPosition(t){let e={...t};for(let n=this.editDeltas.length-1;n>=0;n--){const s=this.editDeltas[n];(e.line>s.range.end.line+s.lineDelta||e.line===s.range.end.line+s.lineDelta&&e.character>=s.range.end.character+(s.lineDelta===0?s.charDelta:0))&&(e.line-=s.lineDelta,e.line===s.range.end.line&&(e.character-=s.charDelta))}return e}applyTextEdit(t,e,n){const s=t.slice(0,e.start.line),o=t[e.start.line]??"",r=t[e.end.line]??"",c=t.slice(e.end.line+1),a=o.slice(0,e.start.character),g=r.slice(e.end.character),d=n.split(`
`),D=d.length-(e.end.line-e.start.line+1),y=d.length===1?d[0].length-(e.end.character-e.start.character):d[d.length-1].length-e.end.character;this.editDeltas.push({range:e,lineDelta:D,charDelta:y});let S;if(d.length===1){const O=a+d[0]+g;S=[...s,O,...c]}else{const O=a+d[0],_=d[d.length-1]+g,C=d.slice(1,-1);S=[...s,O,...C,_,...c]}return S}setLines(t){this.lines=t.split(`
`)}getText(){return this.lastGetTextVersion<this.version&&(this.text=this.lines.join(`
`),this.lastGetTextVersion=this.version),this.text}static compositeKey(t,e){return`${t}:${e.line}:${e.character}`}}class R{constructor(){h(this,"documents",new Map)}getDocument(t){return this.documents.get(t)}hasDocument(t){return this.documents.has(t)}createDocument(t,e){this.documents.set(t,e)}deleteDocument(t){this.documents.delete(t)}zipAllDocuments(){return this.documents.entries()}}class ${constructor(t,e){h(this,"pendingRequestResolve",null);h(this,"ws",null);h(this,"languageServer",null);this.ws=new WebSocket(`ws://${t}:${e}`),this.ws.onopen=()=>this.onOpen(this.ws),this.ws.onmessage=n=>this.onMessage(this.ws,n.data),this.ws.onclose=()=>this.onClose(this.ws),this.ws.onerror=n=>this.onError(this.ws,n)}injectDependencies(t){this.languageServer=t}send(t){var e;(e=this.ws)==null||e.send(JSON.stringify(t))}onOpen(t){var e;(e=this.languageServer)==null||e.logMessage("clarity compiler server socket opened",p.Log),this.ws=t}onMessage(t,e){var n,s,o,r,c;try{const a=JSON.parse(e.toString());if(a.done)(n=this.pendingRequestResolve)==null||n.call(this),this.pendingRequestResolve=null;else if(a.symbol){const g=a.symbol,d=g.location.filepath;(s=this.languageServer)==null||s.dispatchSymbol(d,g)}else if(a.statistic){const g=a.statistic}else if(a.diagnostic){const g={range:{start:{line:a.diagnostic.startLine,character:a.diagnostic.startColumn},end:{line:a.diagnostic.endLine,character:a.diagnostic.endColumn}},severity:a.diagnostic.severity,code:a.diagnostic.code,codeDescription:a.diagnostic.codeDescription?{href:a.diagnostic.codeDescription.href}:void 0,source:"haze compiler",message:a.diagnostic.message},d=a.diagnostic.filepath;(o=this.languageServer)==null||o.dispatchDiagnostic(d,g)}else if(a.message){const g=a.message.text,d=a.message.kind||p.Log;(r=this.languageServer)==null||r.logMessage(g,d)}}catch(a){(c=this.languageServer)==null||c.logMessage(`clarity compiler server socket error parsing message: ${a}`,p.Error)}}onClose(t){var e;(e=this.languageServer)==null||e.logMessage("clarity compiler server socket closed",p.Log)}onError(t,e){var n;(n=this.languageServer)==null||n.logMessage(`clarity compiler server socket error: ${e}`,p.Error)}checkNonNull(){var t;return this.ws?!0:((t=this.languageServer)==null||t.logMessage("clarity compiler server socket error: ws was null",p.Error),!1)}logMessage(t){this.languageServer&&this.languageServer.logMessage(t)}async submitRequest(t){var n;if(!this.checkNonNull())return;const e=new Promise(s=>{this.pendingRequestResolve=s});try{const s=JSON.stringify(t);this.ws.send(s)}catch(s){(n=this.languageServer)==null||n.logMessage(`clarity compiler server socket error submitting work request: ${s}`,p.Error)}await e}async requestCompile(t){if(!this.checkNonNull())return;const e={type:"compile",text:t.join(`
`)};await this.submitRequest(e)}}function I(i){switch(i){case"haze":return[{label:"immutable",kind:l.Keyword,detail:"Type qualifier declaring logical and bitwise constancy.",documentation:"Denotes that instances of the specified type cannot be modified after initialization.",insertText:"immutable ",insertTextFormat:1,insertTextMode:1},{label:"mutable",kind:l.Keyword,detail:"Type qualifier declaring logical and bitwise mutability.",documentation:"Denotes that instances of the specified type can be modified after initialization.",insertText:"mutable ",insertTextFormat:1,insertTextMode:1},{label:"unsigned",kind:l.Keyword,detail:"Type signedness declaring an unsigned integrality.",documentation:"Denotes that instances of the specified type should be treated as unsigned.",insertText:"unsigned ",insertTextFormat:1,insertTextMode:1},{label:"signed",kind:l.Keyword,detail:"Type signedness declaring a signed integrality.",documentation:"Denotes that instances of the specified type should be treated as signed.",insertText:"signed ",insertTextFormat:1,insertTextMode:1},{label:"value",kind:l.Keyword,detail:"Type storage declaring a value type.",documentation:"Denotes that instances of the specified type are treated and passed by value.",insertText:"value ",insertTextFormat:1,insertTextMode:1},{label:"ptr",kind:l.Keyword,detail:"Type storage declaring a pointer (reference) type.",documentation:"Denotes that instances of the specified type serve as reference pointers to a different underlying object.",insertText:"ptr ",insertTextFormat:1,insertTextMode:1},{label:"struct",kind:l.Keyword,detail:"Type specifier declaring a struct (composite) type.",documentation:"Denotes that instances of the specified type refer to a composite object.",insertText:"struct ",insertTextFormat:1,insertTextMode:1},{label:"byte",kind:l.Keyword,detail:"Type specifier declaring a byte integer type.",documentation:"Denotes that instances of the specified type are byte integers exactly 8 bits in size.",insertText:"word ",insertTextFormat:1,insertTextMode:1},{label:"word",kind:l.Keyword,detail:"Type specifier declaring a word integer type.",documentation:"Denotes that instances of the specified type are word integers exactly 16 bits in size.",insertText:"word ",insertTextFormat:1,insertTextMode:1},{label:"dword",kind:l.Keyword,detail:"Type specifier declaring a double-word integer type.",documentation:"Denotes that instances of the specified type are double-word integers exactly 32 bits in size.",insertText:"dword ",insertTextFormat:1,insertTextMode:1},{label:"qword",kind:l.Keyword,detail:"Type specifier declaring a quad-word integer type.",documentation:"Denotes that instances of the specified type are quad-word integers exactly 64 bits in size.",insertText:"qword ",insertTextFormat:1,insertTextMode:1},{label:"string",kind:l.Keyword,detail:"Type qualifier declaring a string type.",documentation:"Denotes that instances of the specified type refer to character strings.",insertText:"string ",insertTextFormat:1,insertTextMode:1},{label:"nvr",kind:l.Keyword,detail:"Type qualifier declaring a non-valueâ€“returning function..",documentation:"Denotes that a function produces no return value. Not valid for variable declarations.",insertText:"nvr ",insertTextFormat:1,insertTextMode:1},{label:"declare",kind:l.Keyword,detail:"Keyword declaring or defining a variable or function.",documentation:"Declares or defines a variable or function with the specified name and associated type(s).",insertText:"declare ",insertTextFormat:1,insertTextMode:1},{label:"proto",kind:l.Keyword,detail:"Keyword declaring a function prototype.",documentation:"Declares a function signature prototype with the specified name and associated type(s).",insertText:"proto ",insertTextFormat:1,insertTextMode:1},{label:"print",kind:l.Keyword,detail:"Keyword printing a string or integer type to the standard console.",documentation:"Prints the specified value to the console output.",insertText:"print(${1:value})",insertTextFormat:2,insertTextMode:1},{label:"intrinsic",kind:l.Keyword,detail:"IMPORTANT: DO NOTE USE.",documentation:"Reserved keyword for future language use. IMPORTANT: DO NOT USE.",insertText:"intrinsic ",insertTextFormat:1,insertTextMode:1},{label:"function",kind:l.Keyword,detail:"Keyword declaring a function.",documentation:"Declares a function with the specified name and associated type(s).",insertText:"function ${1:type} ${2:name} = (${3:params})\n{\n	$0\n}",insertTextFormat:2,insertTextMode:2},{label:"return",kind:l.Keyword,detail:"Keyword returning a value from a function.",documentation:"Returns the specified value from the current function.",insertText:"return ${1:value}",insertTextFormat:2,insertTextMode:1},{label:"while",kind:l.Keyword,detail:"Keyword denoting a uniconditional loop statement.",documentation:"Executes the given block of code while the specified condition remains true.",insertText:`while (\${1:condition})
{
	$0
}`,insertTextFormat:2,insertTextMode:2},{label:"for",kind:l.Keyword,detail:"Keyword denoting a definite conditional loop statement.",documentation:"Executes the given block of code according to the specified initialization, condition, and increment.",insertText:"for (${1:initialization}; ${2:condition}; ${3:increment})\n{\n	$0\n}",insertTextFormat:2,insertTextMode:2},{label:"if",kind:l.Keyword,detail:"Conditional statement corresponding to branched machine logic.",documentation:"Conditionally executes the given block of code according to the specified condition.",insertText:`if (\${1:condition})
{
	$0
}`,insertTextFormat:2,insertTextMode:2},{label:"else",kind:l.Keyword,detail:"Conditional statement corresponding to branched machine logic.",documentation:"Conditionally executes the given block of code when the associated condition proved false.",insertText:`else
{
	$0
}`,insertTextFormat:2,insertTextMode:2},{label:"asm",kind:l.Keyword,detail:"Keyword denoting a _Haze_ inline assembly block.",documentation:"Denotes an Haze inline assembly statement useful for low-level operations.",insertText:`asm {
	$0
}`,insertTextFormat:2,insertTextMode:2},{label:".define",kind:l.Keyword,detail:"Compiler directive defining a compile-time constant.",documentation:"Defines a compile-time constant with the specified name and value. Not a preprocessor directive.",insertText:".define ${1:name} = ${2:value}",insertTextFormat:2,insertTextMode:1},{label:".include",kind:l.Keyword,detail:"Preprocessor directive including a file into the current compilation unit.",documentation:"Lexically pastes the specified file into the current compilation unit at the point of inclusion.",insertText:'.include "${1:file}"',insertTextFormat:2,insertTextMode:1},{label:".macro",kind:l.Keyword,detail:"Preprocessor directive defining a macro.",documentation:"Defines a macro with the specified name and parameters. Not a preprocessor directive.",insertText:`.macro \${1:name} = (\${2:params})
{
	$0
}`,insertTextFormat:2,insertTextMode:2},{label:".hook",kind:l.Keyword,detail:"IMPORTANT: DO NOTE USE.",documentation:"Reserved keyword for future language use. IMPORTANT: DO NOT USE.",insertText:".hook ${1:name}",insertTextFormat:2,insertTextMode:1},{label:".unhook",kind:l.Keyword,detail:"IMPORTANT: DO NOTE USE.",documentation:"Reserved keyword for future language use. IMPORTANT: DO NOT USE.",insertText:".unhook ${1:name}",insertTextFormat:2,insertTextMode:1}];case"hazea":return[{label:"move",kind:l.Keyword,detail:"Inline assembly instruction moving a value from one location to another.",documentation:"Moves the specified value from the source location to the destination location.",insertText:"move ${1:destination}, ${2:source}",insertTextFormat:2,insertTextMode:1},{label:"load",kind:l.Keyword,detail:"Inline assembly instruction loading a value from memory into a register.",documentation:"Loads the specified value from the memory address into the specified register.",insertText:"load ${1:register}, ${2:address}",insertTextFormat:2,insertTextMode:1},{label:"save",kind:l.Keyword,detail:"Inline assembly instruction saving a value from a register to memory.",documentation:"Saves the specified value from the register to the specified memory address.",insertText:"save ${1:address}, ${2:register}",insertTextFormat:2,insertTextMode:1},{label:"copy",kind:l.Keyword,detail:"Inline assembly instruction copying a an immediate value into the specified register.",documentation:"Copies the specified immediate value into the specified register.",insertText:"copy ${1:register}, ${2:value}",insertTextFormat:2,insertTextMode:1},{label:"iadd",kind:l.Keyword,detail:"Inline assembly instruction adding two integer values.",documentation:"Adds the two specified integer values and stores the result in the destination register.",insertText:"iadd ${1:destination}, ${2:source1}, ${3:source2}",insertTextFormat:2,insertTextMode:1},{label:"isub",kind:l.Keyword,detail:"Inline assembly instruction subtracting two integer values.",documentation:"Subtracts the second specified integer value from the first and stores the result in the destination register.",insertText:"isub ${1:destination}, ${2:source1}, ${3:source2}",insertTextFormat:2,insertTextMode:1},{label:"band",kind:l.Keyword,detail:"Inline assembly instruction performing a bitwise AND operation on two integer values.",documentation:"Performs a bitwise AND operation on the two specified integer values and stores the result in the destination register.",insertText:"band ${1:destination}, ${2:source1}, ${3:source2}",insertTextFormat:2,insertTextMode:1},{label:"bior",kind:l.Keyword,detail:"Inline assembly instruction performing a bitwise OR operation on two integer values.",documentation:"Performs a bitwise OR operation on the two specified integer values and stores the result in the destination register.",insertText:"bior ${1:destination}, ${2:source1}, ${3:source2}",insertTextFormat:2},{label:"bxor",kind:l.Keyword,detail:"Inline assembly instruction performing a bitwise XOR operation on two integer values.",documentation:"Performs a bitwise XOR operation on the two specified integer values and stores the result in the destination register.",insertText:"bxor ${1:destination}, ${2:source1}, ${3:source2}",insertTextFormat:2},{label:"call",kind:l.Keyword,detail:"Inline assembly instruction calling a function.",documentation:"Calls the specified function with any applied arguments.",insertText:"call ${1:function}",insertTextFormat:2,insertTextMode:1},{label:"exit",kind:l.Keyword,detail:"Inline assembly instruction returning from a function.",documentation:"Returns from the current function to the address specified on the stack.",insertText:"exit",insertTextFormat:2,insertTextMode:1},{label:"push",kind:l.Keyword,detail:"Inline assembly instruction pushing a value onto the stack.",documentation:"Pushes the specified register value onto the stack, decrementing the stack pointer.",insertText:"push ${1:source}",insertTextFormat:2,insertTextMode:1},{label:"pull",kind:l.Keyword,detail:"Inline assembly instruction pulling a value from the stack.",documentation:"Pulls the top value from the stack into the specified register, incrementing the stack pointer.",insertText:"pull ${1:destination}",insertTextFormat:2,insertTextMode:1},{label:"brnz",kind:l.Keyword,detail:"Inline assembly instruction branching to a label if the specified register is not zero.",documentation:"Branches to the specified label if the value in the specified register is not zero.",insertText:"brnz ${1:register}, ${2:label}",insertTextFormat:2,insertTextMode:1},{label:"stop",kind:l.Keyword,detail:"Inline assembly instruction immediately stopping execution of the current program.",documentation:"Stops the execution of the current program immediately, without returning to the caller.",insertText:"stop",insertTextFormat:2,insertTextMode:1}];case"hazei":return[];case"hazes":return[];default:return[]}}class v{constructor(){h(this,"hasInitialized",!1);h(this,"hasShutdown",!1);h(this,"client",null);h(this,"compilerDriver",null);h(this,"documentManager",null)}injectDependencies(t,e){this.compilerDriver=t,this.documentManager=e}execute(t,...e){const n=this[t];if(typeof n=="function")return n.apply(this,e);throw new Error(`Method "${t}" does not exist on type LanguageServer`)}onOpen(t){console.log("clarity haze language server socket opened"),this.client=t}onMessage(t,e){try{var n=JSON.parse(e.toString());if(!this.hasInitialized){n.id&&t.postMessage(JSON.stringify(f(n.id,x.SERVER_NOT_INITIALIZED.code,x.SERVER_NOT_INITIALIZED.message)));return}try{const o=n.method.replace("/","_");this.execute(o,t,n)}catch{t.postMessage(JSON.stringify(f(n.id||null,x.METHOD_NOT_FOUND.code,x.METHOD_NOT_FOUND.message+`: ${n.method}`)))}}catch{t.postMessage(JSON.stringify(f(null,x.PARSE_ERROR.code,x.PARSE_ERROR.message)))}}onClose(t){console.log("clarity haze language server socket closed")}onError(t,e){console.error("clarity haze language server socket error:",e)}async initialize(t,e){t.postMessage(JSON.stringify(m(e.id,{capabilities:{textDocumentSync:M.Incremental,definitionProvider:!0,typeDefinitionProvider:!0,hoverProvider:!0,completionProvider:{resolveProvider:!0,triggerCharacters:[".","(","[","{"]},documentSymbolProvider:!0,documentHighlightProvider:!0,semanticTokensProvider:{legend:{tokenTypes:["file","module","namespace","package","class","method","property","field","constructor","enum","interface","function","variable","constant","string","number","boolean","array","object","key","null","enumMember","struct","event","operator","typeParameter"],tokenModifiers:["signed","unsigned","mutable","immutable","value","ptr","nvr","struct","string","qword","dword","word","byte"]},full:!0},workspaceSymbolProvider:!0,workspace:{didChangeConfiguration:!0,didChangeWatchedFiles:!0}}})))}async initialized(t,e){this.hasInitialized=!0}async shutdown(t,e){this.hasShutdown=!0,t.postMessage(JSON.stringify(m(e.id,null)))}async exit(t,e){throw this.hasShutdown?new Error("Exit Code 0: OK"):new Error("Exit Code 1: Not Shut Down")}async textDocument_definition(t,e){var c;const n=e.params.textDocument.uri,s=e.params.position,o=(c=this.documentManager)==null?void 0:c.getDocument(n);if(!o){this.uriDoesNotExist(t,n,e.id);return}const r=o.getSymbolAroundPosition(s);if(r){if(!r.isDeclaration){let a=[];const g=o.getSymbolsByName(r.symbol.name);for(const d of g)d.isDeclaration&&a.push({uri:d.symbol.location.uri,range:d.symbol.location.range});if(a.length>0){t.postMessage(JSON.stringify(m(e.id,a)));return}}t.postMessage(JSON.stringify(m(e.id,[{uri:r.symbol.location.uri,range:r.symbol.location.range}])))}else t.postMessage(JSON.stringify(m(e.id,null)))}async textDocument_completion(t,e){var c;const n=e.params.textDocument.uri,s=e.params.position;e.params.context;const o=(c=this.documentManager)==null?void 0:c.getDocument(n);if(!o){this.uriDoesNotExist(t,n,e.id);return}const r=o.getTextFragmentBeforePosition(s);if(r){const a=o.getSymbolsByNamePrefix(r),d=I(o.languageId).filter(y=>y.label.startsWith(r)),D=[];D.push(...d);for(const y of a)D.push({label:y.symbol.name,kind:l.Variable,detail:y.symbol.kind.toString(),documentation:void 0,insertText:y.symbol.name,insertTextFormat:1});t.postMessage(JSON.stringify(m(e.id,D)))}else t.postMessage(JSON.stringify(m(e.id,[])))}async textDocument_highlight(t,e){var g;const n=e.params.textDocument.uri,s=e.params.position,o=(g=this.documentManager)==null?void 0:g.getDocument(n);if(!o){this.uriDoesNotExist(t,n,e.id);return}const r=o.getSymbolAroundPosition(s);if(!r){t.postMessage(JSON.stringify(m(e.id,null)));return}const a=o.getSymbolsByName(r.symbol.name).map(d=>({range:d.symbol.location.range,kind:d.isDeclaration?void 0:N.Write}));t.postMessage(JSON.stringify(m(e.id,a)))}async textDocument_references(t,e){var d,D;const n=e.params.textDocument.uri,s=e.params.position,o=((d=e.params.context)==null?void 0:d.includeDeclaration)??!1,r=(D=this.documentManager)==null?void 0:D.getDocument(n);if(!r){this.uriDoesNotExist(t,n,e.id);return}const c=r.getSymbolAroundPosition(s);if(!c){t.postMessage(JSON.stringify(m(e.id,[])));return}const g=r.getSymbolsByName(c.symbol.name).filter(y=>o||!y.isDeclaration);t.postMessage(JSON.stringify(m(e.id,g.map(y=>({uri:y.symbol.location.uri,range:y.symbol.location.range})))))}async textDocument_didOpen(t,e){var a,g;const n=e.params.textDocument.uri,s=e.params.textDocument.languageId,o=e.params.textDocument.version,r=e.params.textDocument.text;if(!v.validateDocumentUri(e)){t.postMessage(JSON.stringify(f(e.id,x.INVALID_PARAMS.code,`Invalid document URI: ${n}`)));return}if(!v.validateLanguage(s)){t.postMessage(JSON.stringify(f(e.id,x.INVALID_PARAMS.code,`Unsupported language: ${s}`)));return}let c=(a=this.documentManager)==null?void 0:a.getDocument(n);if(c)o>c.version&&(c.version=o,c.lines=r.split(`
`),await this.requestCompleteRefresh(t,n,c.lines));else{const d=new k(n,s,o);d.lines=r.split(`
`),d.invalidateSymbols(),(g=this.documentManager)==null||g.createDocument(n,d),c=d,await this.requestCompleteRefresh(t,n,d.lines)}this.publishDiagnostics(t,c)}textDocument_didChange(t,e){var a;const n=e.params.textDocument.uri,s=e.params.textDocument.version,o=e.params.contentChanges,r=(a=this.documentManager)==null?void 0:a.getDocument(n);if(!r||s<=r.version)return;let c=r.lines??[];for(const g of o)g.range?c=r.applyTextEdit(c,g.range,g.text):c=g.text.split(`
`);r.lines=c,r.version=s,this.requestCompleteRefresh(t,n,c)}textDocument_didClose(t,e){var o;const n=e.params.textDocument.uri,s=(o=this.documentManager)==null?void 0:o.getDocument(n);s&&(s.lines=[])}textDocument_didSave(t,e){var r,c,a;const n=e.params.textDocument.uri;let s=e.params.text;if(s){const g=(r=this.documentManager)==null?void 0:r.getDocument(n);g&&(g.lines=s.split(`
`))}const o=(a=(c=this.documentManager)==null?void 0:c.getDocument(n))==null?void 0:a.lines;o&&this.requestCompleteRefresh(t,n,o)}textDocument_didChangeConfiguration(t,e){this.sendMessageToClient(t,"The client configuration has changed on disk. Please reload the editor to apply the new settings.",p.Info)}textDocument_didChangeWatchedFiles(t,e){this.sendMessageToClient(t,"One or more workspace files has been changed on disk. Please reload the document to prevent a loss of data.",p.Info)}textDocument_hover(t,e){var c;const n=e.params.textDocument,s=e.params.position,o=(c=this.documentManager)==null?void 0:c.getDocument(n);if(!o){this.uriDoesNotExist(t,n,e.id);return}const r=o.getSymbolAroundPosition(s);r?t.postMessage(JSON.stringify(m(e.id,{contents:r.symbol.name,range:r.symbol.location.range}))):t.postMessage(JSON.stringify(m(e.id,null)))}textDocument_documentSymbol(t,e){var r;const n=e.params.textDocument.uri,s=(r=this.documentManager)==null?void 0:r.getDocument(n);if(!s){this.uriDoesNotExist(t,n,e.id);return}const o=s==null?void 0:s.getAllSymbols();t.postMessage(JSON.stringify(m(e.id,o)))}workspace_symbol(t,e){var o;const n=e.params.query,s=[];for(const[r,c]of((o=this.documentManager)==null?void 0:o.zipAllDocuments())||[])for(const a of c.getAllSymbols())(n===""||a.symbol.name.includes(n))&&s.push(a.symbol);t.postMessage(JSON.stringify(m(e.id,s)))}publishDiagnostics(t,e){t.postMessage(JSON.stringify(T("textDocument/publishDiagnostics",{uri:e.uri,version:e.version,diagnostics:e.getDiagnostics()||[]},crypto.randomUUID())))}dispatchDiagnostic(t,e){var s;const n=(s=this.documentManager)==null?void 0:s.getDocument(t);if(!n){this.client&&this.uriDoesNotExist(this.client,t);return}n.addDiagnostic(e)}dispatchSymbol(t,e){var s;const n=(s=this.documentManager)==null?void 0:s.getDocument(t);if(!n){this.client&&this.uriDoesNotExist(this.client,t);return}n.upsertSymbol(e)}logMessage(t,e=p.Log){this.client&&this.sendLogToClient(this.client,t,e)}async requestCompleteRefresh(t,e,n,s){var c,a;const o=(c=this.documentManager)==null?void 0:c.getDocument(e);if(!o){this.uriDoesNotExist(t,e,s);return}let r=n||o.lines;o.lines=r,await((a=this.compilerDriver)==null?void 0:a.requestCompile(r)),this.publishDiagnostics(t,o)}sendMessageToClient(t,e,n=p.Info){t.postMessage(JSON.stringify(T("window/showMessage",{type:n,message:e},crypto.randomUUID())))}sendLogToClient(t,e,n=p.Log){t.postMessage(JSON.stringify(T("window/logMessage",{type:n,message:e},null)))}uriDoesNotExist(t,e,n){t.postMessage(JSON.stringify(f(n||null,x.INVALID_PARAMS.code,x.INVALID_PARAMS.message+`Document with URI ${e} not found`)))}static validateLanguage(t){return["haze","hazes","hazei"].includes(t)}static validateDocumentUri(t){const e=t.params.textDocument.uri;return!(!e||typeof e!="string")}}const A="localhost",L="8080";var z=new R,E=new $(A,L),w=new v;w.injectDependencies(E,z),E.injectDependencies(w);let b=null;self.addEventListener("message",i=>{var t;console.log("language server received message:",i.data),((t=i.data)==null?void 0:t.type)==="connect"&&i.data.port&&(b=i.data.port,b&&(b.addEventListener("message",e=>{w.onMessage(b,e.data)}),b.addEventListener("messageerror",e=>{w.onError(b,e.data)}),b.start()))}),w.onOpen({postMessage:i=>b==null?void 0:b.postMessage(i)})})();
